# 재귀

재귀는 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤, 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출하여 실행하는 함수

=> **수학적 귀납법**으로 사고하는 것이 중요!

수학적 귀납법
1번 도미노가 쓰러진다.
k번 도미노가 쓰러지면 k+1 도미노도 쓰러진다.

```cpp
void func1(int n){
    if(n == 0) return;
    cout << n << ' ';
    func1(n-1);
}
```
func1(1)이 1을 출력한다.
func1(k)가 k k-1 k-2 ... 1을 출력한다.
func1(k+1)은 k+1 k k-1 k-2 ... 1을 출력한다.

### 재귀함수의 조건 ###
특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야함(Base Condition)
모든 입력은 base condition으로 수렴해야함!

### 재귀에 대한 정보 ###
1. 함수의 인자로 어떤 것을 받고 어디까지 계산 한 후, 자기자신에게 넘겨줄지 명확하게 해야함 -> 모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있음 
=> 재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지만 메모리/시간에서는 손해를 봄

2. 한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음
```cpp
int fibo(int n){
    if(n <= 1)  return 1;
    return fibo(n-1) + fibo(n-2);
}
```
-> 시간복잡도 O(2ⁿ) 

3. 재귀함수가 자기 자신을 부를 때 스택 영역에 계속 누적이 됨

## 알고리즘 순서 ##
->아래와 같은 step으로 재귀를 작성

1. 함수의 정의
2. base condition 
3. 재귀 식

## 예제 ##
### 1629_곱셈 (거듭제곱)
https://www.acmicpc.net/problem/1629 

$a^b \mod b$ 
-> 시간 제한 0.5s로 그냥 반복돌려서 곱셈하는 것은 안됨,, O(n)말고!

ex) $12^{116} \mod 67$   
$a^n * a^n = a^{2n}$  
$12^{58} = 4 (mod 67) -> 12^{116} = 16(mod 67)$ 

-> 1승을 계산할 수 있다.
-> k승을 계산했으면 2k승과 2k+1승도 O(1)에 계산할 수 있다

```cpp
#include <iostream>
#include <cmath>
using namespace std;

long long a, b, c;
int pow(int a, int b, int c){
    // 기저 상태
    if(b == 1)    return a % c;
    // 재귀적으로, a^(b/2)mod b 계산해 val에 대입
    long long val = pow(a, b/2, c);
    // val 제곱에 나머지 = 우리가 구하고자 하는 나머지
    val = val * val % c;
    if(b % 2 == 0)  return val;// 짝수
    return val * a % c; // 홀수-> a한번 더 곱한 나머지로 구해야 함
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> a >> b >> c;
    cout << pow(a, b, c);
    return 0;
}
```

### 11729_하노이 탑 이동순서 (하노이탑)
https://www.acmicpc.net/problem/11729

n-1개의 원판을 기둥 1에서 기둥 2로 옮긴다.
n번 원판을 기둥1에서 기둥 3으로 옮긴다.
n-1개의 원판을 기둥2에서 기둥3으로 옮긴다  
-> 원판이 n-1개일 때 옮길 수 있으면 원판이 n개일때도 옮길 수 있다!  

원판이 1개일 때 원판을 내가 원하는 곳으로 옮길 수 있다.  
원판이 k개일 때 옮길 수 있으면 원판이 k+1일때에도 옮길 수 있다.

1. 함수의 정의  
    void func(int a, int b, int n)  
    원판 n개를 a번 기둥에서 b번 기둥으로 옮기는 방법을 출력하는 함수  

2. base condition  
n=1일때, `cout << a << ' ' << b << '\n;`

3. 재귀식  
    1. n-1개의 원판을 기둥 a에서 기둥 6-a-b로 옮긴다.  
    `func(a, 6-a-b, n-1);` // 번호의 합이 6이라, 6-a-b

    2. n번 원판을 기둥 a에서 기둥 b로 옮긴다.  
    `cout << a << ' ' << b << '\n;`

    3. n-1개의 원판을 기둥 6-a-b에서 기둥 b로 옮긴다.    
    `func(6-a-b, b, n-1);`    

* 옮긴 횟수: 원판 K개를 옮기기 위해 A번이 필요하다면, k+1개를 옮길 때는 k개의 원판을 빈 곳으로 옮길 때 A번, k+1번 원판을 옮길 때 1번, k개의 원판을 다시 빈곳에서 목적지로 옮길 때 A번이 필요하니 2A+1번 이동이 필요
-> 즉,, 초항이 1이라 이 수열의 일반항은 $2^k-1$이 된다.

