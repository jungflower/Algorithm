# 다이나믹 프로그래밍
### 다이나믹 프로그래밍
: 여러개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘
-> 문제를 해결하기 위해 점화식을 찾아낸 후, 점화식의 항을 밑에서부터 차례로 구해나가서 답을 알아내는 형태!

```cpp
// 재귀
int fibo(int n){
    if(n <= 1)  return 1;
    return fibo(n-1) + fibo(n-2);
}
```

```cpp
int fibo(int n){
    int f[20];
    f[0] = f[1] = 1;
    for(int i=2; i <= n; ++i)
        f[i] = f[i-1] + f[i-2];
    return f[n];
}
```
![alt text](image.png)

## DP 푸는 방법
1. 테이블 정의하기  

2. 점화식 찾기  

3. 초기값 정하기  

## 예제
### 9095_1,2,3 더하기

1. 테이블 정의하기  
`D[i] = i`를 1,2,3의 합으로 나타내는 방법의 수

2. 점화식 찾기  
D[4] = ?  
1+1+1+**1**, 3+**1**, 2+1+**1**, 1+2+**1** (3을 1,2,3의 합으로 나타내는 방법)  
1+1+**2**, 2+**2**  (2를 1,2,3의 합으로 나타내는 방법) **+2**, D[2]  
1+**3**(1을 1,2,3의 합으로 나타내는 방법) **+3**, D[1]  
`D[4] = D[1] + D[2] + D[3]`

3. 초기값 정하기  
D[1] = 1, D[2] = 2, D[3] = 4  
D[i] = D[i-1] + D[i-2] + D[i-3] 이니 초기값이 최소 3개는 주어져야함!

```cpp
#include <iostream>
using namespace std;

int t;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> t;
    while(t--){
        int n;
        cin >> n;

        int dp[12];
        dp[1] = 1; dp[2] = 2; dp[3] = 4;
        for(int i=4; i <= n; ++i){
            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
        }
        cout << dp[n] << '\n';
    }
    return 0;
}
```


